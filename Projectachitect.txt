Developer
   ‚Üì
GitHub
   ‚Üì
Jenkins (EC2)
   ‚Üì
Maven Build
   ‚Üì
SonarQube
   ‚Üì
Nexus (Artifact Upload)
   ‚Üì
Docker Image
   ‚Üì
Trivy Scan
   ‚Üì
Amazon ECR
   ‚Üì
AWS EKS
   ‚Üì
ALB Ingress + ACM SSL
   ‚Üì
Users (HTTPS)


1Ô∏è‚É£ AWS Prerequisites (Mention in README)

‚úî VPC (public + private subnets)
‚úî EKS cluster (managed nodes)
‚úî IAM Roles (EKS, Jenkins, ECR)
‚úî Amazon ECR repository
‚úî ACM SSL certificate
‚úî ALB Ingress Controller

2Ô∏è‚É£ Updated Project Structure
devops-eks-project/
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ pom.xml
‚îÇ
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îÇ
‚îú‚îÄ‚îÄ jenkins/
‚îÇ   ‚îî‚îÄ‚îÄ Jenkinsfile
‚îÇ
‚îú‚îÄ‚îÄ k8s/
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îú‚îÄ‚îÄ ingress.yaml
‚îÇ
‚îú‚îÄ‚îÄ nexus/
‚îÇ   ‚îî‚îÄ‚îÄ settings.xml
‚îÇ
‚îî‚îÄ‚îÄ README.md


3Ô∏è‚É£ Nexus Artifact Upload
nexus/settings.xml
<settings>
  <servers>
    <server>
      <id>nexus</id>
      <username>admin</username>
      <password>nexus-password</password>
    </server>
  </servers>
</settings>


4Ô∏è‚É£ Dockerfile 
FROM openjdk:11-jre-slim
WORKDIR /app
COPY target/devops-app-1.0.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]


5Ô∏è‚É£ AWS ECR Image Push
Create ECR repo:

aws ecr create-repository --repository-name devops-app

ECR Image format:
ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com/devops-app:latest


6Ô∏è‚É£ Jenkinsfile (FULL ‚Äì Production Level)
jenkins/Jenkinsfile
pipeline {
  agent any

  environment {
    AWS_REGION = "ap-south-1"
    ECR_REPO = "123456789.dkr.ecr.ap-south-1.amazonaws.com/devops-app"
  }

  stages {

    stage('Checkout') {
      steps {
        git branch: 'main', url: 'https://github.com/yourname/devops-eks-project.git'
      }
    }

    stage('Build & Test') {
      steps {
        sh 'mvn clean package'
      }
    }

    stage('SonarQube') {
      steps {
        withSonarQubeEnv('sonarqube') {
          sh 'mvn sonar:sonar'
        }
      }
    }

    stage('Upload Artifact to Nexus') {
      steps {
        sh 'mvn deploy -s nexus/settings.xml'
      }
    }

    stage('Docker Build') {
      steps {
        sh 'docker build -t devops-app .'
      }
    }

    stage('Trivy Scan') {
      steps {
        sh 'trivy image devops-app'
      }
    }

    stage('Push Image to ECR') {
      steps {
        sh '''
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REPO
        docker tag devops-app:latest $ECR_REPO:latest
        docker push $ECR_REPO:latest
        '''
      }
    }

    stage('Deploy to EKS') {
      steps {
        sh '''
        kubectl apply -f k8s/
        '''
      }
    }
  }
}


7Ô∏è‚É£ Kubernetes Deployment (EKS)
k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: devops-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: devops-app
  template:
    metadata:
      labels:
        app: devops-app
    spec:
      containers:
      - name: app
        image: 123456789.dkr.ecr.ap-south-1.amazonaws.com/devops-app:latest
        ports:
        - containerPort: 8080

k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: devops-service
spec:
  type: NodePort
  selector:
    app: devops-app
  ports:
  - port: 80
    targetPort: 8080


8Ô∏è‚É£ Ingress + SSL (AWS ALB)
Prerequisites

‚úî Install AWS Load Balancer Controller
‚úî SSL certificate from ACM

k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: devops-ingress
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-south-1:123456789:certificate/xxxx
spec:
  rules:
  - host: devops.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: devops-service
            port:
              number: 80


‚úÖ HTTPS enabled
‚úÖ SSL termination via ACM
‚úÖ Production-grade ALB



Kubernetes Auto-Scaling on AWS EKS
(HPA + Cluster Autoscaler)

You‚Äôll achieve two-level scaling:

Layer	Scales What	Tool
Pod level	Pods inside a Deployment	HPA
Node level	EC2 worker nodes	Cluster Autoscaler (CA)
1Ô∏è‚É£ Prerequisites (Must Mention)

‚úî EKS cluster
‚úî Metrics Server installed
‚úî Managed Node Group (ASG based)
‚úî IAM OIDC provider enabled

2Ô∏è‚É£ Install Metrics Server (Required for HPA)
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml


Verify:

kubectl top pods
kubectl top nodes

3Ô∏è‚É£ Update Deployment (CPU Requests Required)
k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: devops-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: devops-app
  template:
    metadata:
      labels:
        app: devops-app
    spec:
      containers:
      - name: app
        image: 123456789.dkr.ecr.ap-south-1.amazonaws.com/devops-app:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            cpu: "200m"
            memory: "256Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"


üìå Without requests, HPA will NOT work

4Ô∏è‚É£ Horizontal Pod Autoscaler (HPA)
k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: devops-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: devops-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70


Apply:

kubectl apply -f k8s/hpa.yaml


Check:

kubectl get hpa

5Ô∏è‚É£ Test HPA (Optional but Good)
kubectl run load-test --rm -it --image=busybox -- sh
while true; do wget -q -O- http://devops-service; done


Result:
‚úî Pods scale up
‚úî CPU threshold reached

6Ô∏è‚É£ Cluster Autoscaler (CA) on AWS EKS
Step 1: IAM Policy for CA

Attach this policy to node group IAM role:

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "autoscaling:DescribeAutoScalingGroups",
        "autoscaling:DescribeAutoScalingInstances",
        "autoscaling:DescribeLaunchConfigurations",
        "autoscaling:DescribeTags",
        "autoscaling:SetDesiredCapacity",
        "autoscaling:TerminateInstanceInAutoScalingGroup"
      ],
      "Resource": "*"
    }
  ]
}

Step 2: Deploy Cluster Autoscaler
k8s/cluster-autoscaler.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-autoscaler
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cluster-autoscaler
  template:
    metadata:
      labels:
        app: cluster-autoscaler
      annotations:
        cluster-autoscaler.kubernetes.io/safe-to-evict: "false"
    spec:
      serviceAccountName: cluster-autoscaler
      containers:
      - image: registry.k8s.io/autoscaling/cluster-autoscaler:v1.28.0
        name: cluster-autoscaler
        command:
        - ./cluster-autoscaler
        - --cloud-provider=aws
        - --nodes=2:10:eks-nodegroup-name
        - --skip-nodes-with-local-storage=false
        - --expander=least-waste


‚ö† Replace:

eks-nodegroup-name


Apply:

kubectl apply -f k8s/cluster-autoscaler.yaml

7Ô∏è‚É£ How HPA + CA Work Together (Explain This)
Flow:

Traffic increases

CPU usage crosses 70%

HPA adds more pods

Pods can‚Äôt be scheduled

Cluster Autoscaler adds EC2 nodes

New pods get scheduled

Traffic decreases ‚Üí scale down

8Ô∏è‚É£ Verification Commands (Interview Ready)
kubectl get hpa
kubectl describe hpa devops-app-hpa
kubectl get nodes
kubectl logs -n kube-system deployment/cluster-autoscaler




9Ô∏è‚É£ README (Resume-Ready)
## AWS EKS Corporate DevOps Project

### Tools & Technologies
AWS (EKS, ECR, IAM, VPC, ACM), Jenkins, Maven, Docker, Nexus,
SonarQube, Trivy, Kubernetes, Prometheus, Grafana

### Key Highlights
- CI/CD pipeline with Jenkins
- Artifact management using Nexus
- Container security scanning with Trivy
- Docker image stored in Amazon ECR
- Application deployed on AWS EKS
- ALB Ingress with SSL using ACM
- Monitoring with Prometheus & Grafana